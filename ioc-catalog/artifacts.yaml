# Catalog Artifacts
# ------------------------------------------------------------------------------
# PURPOSE
# This file stores DURABLE, non-regex indicators you can reuse across variants:
# toolchain fingerprints, normalized config hashes, network grammar (header
# order, path templates), persistence templates, injection API sequences,
# mutex/pipe grammars, and forensic breadcrumbs. These survive domain/IP churn,
# repacks, and minor code edits better than atomic hashes or regex alone.
# These are the templates that I'm using - I will update any changes in alignment with my work and experience level.
# 
# HOW TO USE
# - Add an entry per FAMILY or ARCHETYPE you observe. Copy an archetype and fill
#   the <placeholders> with real, normalized values (avoid usernames, timestamps).
# - Keep fields: stability (1–5, resilience across variants), confidence
#   (low|medium|high), visibility (disk|network|memory). They guide rule export.
# - Pair this file with:
#     catalog/regex-iocs.md   → atomic/regex patterns (I really need to change this fucking name)
#     
#     (will be added in the future) catalog/atoms.yml              → volatile atoms (domains, IPs, certs) with expiry
#     (will be added in the future) catalog/ttp.yml                → reusable behavior bundles (for Sigma/YARA logic)
#
# WHAT TO CAPTURE
# - binary_dna: imphash/impfuzzy, TLSH/ssdeep (prefer UNPACKED), sorted-imports
#   hash, section schema hash, toolchain hints (Go build ID, rustc/crates,
#   .NET MVID etc.), optional PE Rich hash / ELF build-id.
# - config_proto: normalized config SHA (parse→sort keys→drop GUIDs/timestamps),
#   key order, crypto quirks (XOR table hash, RC4 key length), framing/magic.
# - network: JA3/JA3S/JARM, TLS cert fingerprint (normalized tuple), HTTP header
#   order & casing, canonical User-Agent, path template, parameter order, beacon
#   cadence (period/jitter/size).
# - persistence: Windows Run/Service/Task names, macOS LaunchAgents/Daemons
#   labels, Linux systemd/cron; include drop path TEMPLATES with env vars.
# - anti_analysis & injection: debugger/VM gates, direct syscalls/unhooking,
#   canonical API sequences (e.g., OpenProcess→VirtualAllocEx→WriteProcessMemory→CreateRemoteThread).
# - artifacts: mutex/pipe GRAMMARS (not a single GUID), drop path templates.
# - forensics: Prefetch/AmCache patterns, key Windows/Sysmon Event IDs with hints.
# - ...
#
# CONVENTIONS
# - IDs: archetype.scope.name.v1 (bump version on breaking changes).
# - Normalize strings: lowercase where safe, strip zero-width/unicode confusables,
#   use env vars (%APPDATA%, ~/Library) and template slots (<Vendor>, <Task>).
# - Prefer “3-of-N” usage when exporting to YARA/Sigma to reduce false positives.
#
# GRADES USED IN THIS CATALOG 
# stability: 1–5  → How well this artifact survives variants/rebuilds.
#   5 = Very durable (family DNA: config schema, header order, toolchain markers)
#   4 = Usually durable (JA3/JA3S bundles, persistence templates)
#   3 = Mixed (some variants change it; keep as part of a bundle)
#   2 = Fragile (often changes across versions/packing)
#   1 = Brittle (use only as supporting context)
#
# confidence: low | medium | high  → Analyst confidence in correctness/attribution.
#   high   = Observed repeatedly; cross-validated from multiple sources
#   medium = Solid evidence but limited samples or partial validation
#   low    = Preliminary/speculative; keep but don’t rely on it alone
#
# visibility: [disk | network | memory | logs]  → Where this artifact is observable.
#   disk   = Filesystem/registry/plists, static binaries, dropped files
#   network= Wire data (HTTP grammar, JA3/JA3S/JARM, beacon cadence)
#   memory = In-memory/unpacked image, decrypted config, API sequences
#   logs   = Telemetry (Sysmon/EDR/SIEM), scheduler/service creation events
#
# perf_cost: 1–5  → Cost to use when converted to rules or hunts.
#   1 = Cheap (string/field checks) … 5 = Expensive (complex/sequence or deep parsing)
#
# severity (optional): low | medium | high  → Operational impact if matched.
#   high = Strong signal of malicious activity; consider alert/block
#   med  = Suspicious; needs context or additional matches
#   low  = Weak signal; primarily triage/pivot value
#
# WORKFLOW
# 1) During RE/DFIR, fill an archetype with observed traits.
# 2) Add stability/confidence/visibility. Link provenance sample SHA256 (prefer something better but at least 256) in notes.
# 3) (Optional) Generate rules/snippets: combine artifacts here + regex from iocs.yml.
# 4) Keep atoms (domains/IPs) out of here—put them in atoms.yml with an expiry.
#
# QUALITY & TESTING
# - Each entry should be supported by at least one sample (provenance in notes).
# - Update rather than duplicate when a family evolves; bump the version.
# - Use catalog/tests/check.sh for regex; for artifacts, keep minimal fixtures
#   (e.g., a normalized config JSON) to recompute and verify hashes offline.
#
# TL;DR
# Think of this file as your “family DNA & behaviors” ledger—high-signal,
# low-churn indicators that make detection and clustering robust over time.
# 
# Sources at the bottom

# BINARY DNA/TOOLCHAIN 

- id: archetype.binary.pe_clang_llvm_toolchain.v1
  name: Clang/LLVM toolchain markers (PE)
  visibility: ["disk"]
  stability: 5
  confidence: high
  binary_dna:
    toolchain: { lang: "c/c++", compiler: "clang", compiler_version: "<fill>", linker: "lld", linker_version: "<fill>" }
    imphash: "<fill>"
    import_set_sha256: "sha256:<sorted-imports>"
    section_fingerprint: "sha256:<canonicalized-sections>"   # names+flags+entropy buckets
    richhash: "<optional-pe-rich-hash>"                      # present if MASM/MSVC libs mixed in
    pdb_paths_norm: ["users/*/proj/*/*.pdb"]                 # if PDB present
  notes: "Clang+LLD on Windows leaves LLVM/LLD version strings and PDBs when built with debug; stable import sets & section schema help cluster variants."

- id: archetype.binary.elf_clang_llvm_toolchain.v1
  name: Clang/LLVM toolchain markers (ELF)
  visibility: ["disk"]
  stability: 5
  confidence: high
  binary_dna:
    toolchain: { lang: "c/c++", compiler: "clang", compiler_version: "<fill>", linker: "lld|ld", linker_version: "<fill>" }
    build_id: "<elf-build-id-if-present>"
    section_fingerprint: "sha256:<canonicalized-sections>"
    dwarf_presence: "<yes/no>"                                # DWARF present?
  notes: "Look for LLVM/Clang strings in .comment/.note and DWARF producer; BUILD-ID + section schema are durable cluster signals."

- id: archetype.binary.pe_gcc_mingw_toolchain.v1
  name: GCC (MinGW) toolchain markers (PE)
  visibility: ["disk"]
  stability: 5
  confidence: high
  binary_dna:
    toolchain: { lang: "c/c++", compiler: "gcc (mingw)", compiler_version: "<fill>", runtime: "libgcc/libstdc++", linker: "ld|lld", linker_version: "<fill>" }
    imphash: "<fill>"
    import_set_sha256: "sha256:<sorted-imports>"
    section_fingerprint: "sha256:<canonicalized-sections>"
    gcc_comment: "<optional: 'GCC: (GNU) X.Y.Z'>"             # if present in .comment/debug
  notes: "MinGW builds often carry GCC version notes and libgcc/libstdc++; PE import layout + section schema are strong clustering features."

- id: archetype.binary.elf_gcc_toolchain.v1
  name: GCC toolchain markers (ELF)
  visibility: ["disk"]
  stability: 5
  confidence: high
  binary_dna:
    toolchain: { lang: "c/c++", compiler: "gcc", compiler_version: "<fill>", linker: "ld|gold|lld", linker_version: "<fill>" }
    build_id: "<elf-build-id-if-present>"
    section_fingerprint: "sha256:<canonicalized-sections>"
    dwarf_presence: "<yes/no>"
  notes: "ELF BUILD-ID + GCC producer strings in DWARF/.comment are common; combine with section fingerprint for robustness."

- id: archetype.binary.pe_msvc_toolchain.v1
  name: MSVC toolchain markers (PE)
  visibility: ["disk"]
  stability: 5
  confidence: high
  binary_dna:
    toolchain: { lang: "c/c++", compiler: "msvc", compiler_version: "<fill>", linker: "link.exe", linker_version: "<fill>" }
    richhash: "<pe-rich-hash>"                                 # strong MSVC signal
    imphash: "<fill>"
    import_set_sha256: "sha256:<sorted-imports>"
    section_fingerprint: "sha256:<canonicalized-sections>"
    pdb_paths_norm: ["users/*/proj/*/*.pdb"]
  notes: "Rich header + PDB path patterns + import set are excellent for clustering MSVC-built families."

- id: archetype.binary.pe_zig_llvm_toolchain.v1
  name: Zig toolchain markers (PE via LLVM)
  visibility: ["disk","memory"]
  stability: 4
  confidence: medium
  binary_dna:
    toolchain: { lang: "zig", zig_version: "<fill>", backend: "LLVM", lld_version: "<fill>" }
    imphash: "<fill>"
    import_set_sha256: "sha256:<sorted-imports>"
    section_fingerprint: "sha256:<canonicalized-sections>"
    pdb_paths_norm: ["users/*/proj/*/*.pdb"]                  # if built with PDBs
  notes: "Zig emits through LLVM/LLD; version strings often appear in debug metadata. Use section/import fingerprints + any embedded Zig version for clustering."

- id: archetype.binary.elf_zig_llvm_toolchain.v1
  name: Zig toolchain markers (ELF via LLVM)
  visibility: ["disk","memory"]
  stability: 4
  confidence: medium
  binary_dna:
    toolchain: { lang: "zig", zig_version: "<fill>", backend: "LLVM", linker: "lld|ld", linker_version: "<fill>" }
    build_id: "<elf-build-id-if-present>"
    section_fingerprint: "sha256:<canonicalized-sections>"
    dwarf_presence: "<yes/no>"
  notes: "On ELF, check DWARF producer for Zig/LLVM, BUILD-ID for clustering, and keep section schema hashed; pair with behavior/config artifacts for high precision."


- id: archetype.binary.pe_go_toolchain.v1
  name: Go toolchain markers (PE/ELF)
  visibility: ["disk"]
  stability: 5
  confidence: high
  binary_dna:
    toolchain: { lang: "go", go_build_id: "<fill>", modules: ["<module@version>", "..."] }
    section_fingerprint: "sha256:<canonicalized-sections>"   # names+flags+entropy buckets
    richhash: "<optional-pe-rich-hash>"
  notes: "Great clustering signal; persists through minor code changes"

- id: archetype.binary.rust_toolchain.v1
  name: Rust toolchain markers
  visibility: ["disk"]
  stability: 5
  confidence: high
  binary_dna:
    toolchain: { lang: "rust", rustc_version: "<fill>", crates: ["<crate>", "..."] }
    section_fingerprint: "sha256:<canonicalized-sections>"
  notes: "Rustc strings & crate names frequently survive packing"

- id: archetype.binary.dotnet_singlefile.v1
  name: .NET single-file loader shell
  visibility: ["disk","memory"]
  stability: 3
  confidence: medium
  binary_dna:
    toolchain: { lang: "dotnet", mvid: "<fill>", assembly_name: "<fill>" }
  notes: "Common loader archetype; pair with persistence entries"

# CONFIG/PROTOCOL FINGERPRINTS

- id: archetype.config.normalized_json.v1
  name: Normalized config hash (JSON-like)
  visibility: ["disk","memory"]
  stability: 5
  confidence: high
  config_proto:
    norm_config_sha256: "<sha256-of-sorted-devolatilized-config>"
    keys_order: ["ver","id","op","enc","data"]   # example; replace with real
    crypto: { xor_table_sha1: "<optional>", rc4_key_len: "<optional>" }
    framing_magic: "0xDEADBEEF"                  # example
  notes: "Parse → sort keys → drop GUIDs/timestamps → hash. Family-grade signature"

- id: archetype.network.http_grammar_checkin.v1
  name: HTTP grammar (header order + path template)
  visibility: ["network"]
  stability: 5
  confidence: high
  network:
    http_header_order: ["Host","User-Agent","Accept","Content-Type"]  # fill actual order
    http_ua: "AcmeClient/1.0"                                         # example UA
    path_template: "/api/v1/checkin"                                  # template only
    params_order: ["id","op","ts"]                                    # if fixed
    beacon: { period_s: 30, jitter_pct: 15, resp_kb: "1.2-1.6" }      # if known
  notes: "Order/casing & paths are durable; survives infra churn"

- id: archetype.network.tls_prints_bundle.v1
  name: TLS handshake prints (JA3/JA3S/JARM)
  visibility: ["network"]
  stability: 4
  confidence: medium
  network:
    ja3:  ["<client-ja3>", "..."]
    ja3s: ["<server-ja3s>", "..."]
    jarm: ["<server-jarm>", "..."]
    tls_cert_fingerprint: "sha256:<normalized-subject+issuer+keysize>"
  notes: "Great pivot; combine with HTTP grammar for high precision"

# PERSISTENCE SETS

- id: archetype.persistence.win_run_service_tasks.v1
  name: Windows persistence triad (Run, Service, Task)
  visibility: ["disk","registry"]
  stability: 4
  confidence: high
  persistence:
    windows:
      - "Run:<name>"                                  # HKCU/HKLM\...\Run
      - "Svc:<service_name>"                          # service install
      - "Task:Microsoft\\Windows\\<vendor>\\<task>"   # scheduled task
  artifacts:
    drop_path_templates:
      - "%APPDATA%\\<Vendor>\\<Product>\\*.dll"
      - "%PROGRAMDATA%\\<Vendor>\\<Product>\\*.exe"
  notes: "These three appear together frequently; strong triage bundle"

- id: archetype.persistence.macos_launchagents.v1
  name: macOS LaunchAgents/Daemons
  visibility: ["disk"]
  stability: 5
  confidence: high
  persistence:
    macos:
      - "LaunchAgents:<label>"
      - "LaunchDaemons:<label>"
  artifacts:
    drop_path_templates:
      - "~/Library/Application Support/<Vendor>/<Product>/*"
  notes: "Label grammar is often family-specific; capture it"

- id: archetype.persistence.linux_systemd_cron.v1
  name: Linux systemd/cron persistence
  visibility: ["disk"]
  stability: 4
  confidence: medium
  persistence:
    linux:
      - "systemd:<name>.service"
      - "cron:@reboot <cmd>"
  artifacts:
    drop_path_templates:
      - "~/.config/<vendor>/<product>/*"
      - "/etc/<vendor>/<product>/*"
  notes: "Record unit names & ExecStart patterns if stable"

# ANTI-ANALYSIS & INJECTION

- id: archetype.anti_analysis.vm_debugger_gates.v1
  name: VM/Debugger gates (common)
  visibility: ["memory"]
  stability: 4
  confidence: medium
  anti_analysis:
    checks: 
      - "IsDebuggerPresent"
      - "CheckRemoteDebuggerPresent"
      - "NtQueryInformationProcess(ProcessDebugPort|ProcessDebugFlags|ProcessBasicInformation)"
      - "NtSetInformationThread(ThreadHideFromDebugger)"
      - "OutputDebugStringA/W"        # odd behaviors when debugger absent
      - "PEB.BeingDebugged|NtGlobalFlag"
      - "rdtsc_delta|QueryPerformanceCounter_delta|SleepSkew"  # time dilation
      - "cpuid_hypervisor_bit"
      - "vboxservice_probe|vmtoolsd_probe|vmware_backdoor_io"
      - "smbios_strings:(VBox|VMware|QEMU|KVM|Parallels)"
      - "mac_oui_vm_vendor"
      - "drivers_present:(VBoxMouse|VBoxGuest|vm3dmp)" # Sandboxes
      - "username/hostname/volume_serial heuristics"
      - "process_blacklist_running:(procmon|wireshark|ida|x64dbg)"
      - "hw_resources_minimal:<2 cores|<4GB RAM>"
    signals: 
      - "timing_deltas_ns",
      - "queried_registry_keys"
      - "queried_processes|services"
      - "SMBIOS/DMI strings"
  notes: "Store as boolean traits—great for clustering and hunting"

- id: archetype.injection.remote_thread.v1
  name: Remote thread injection (classic)
  visibility: ["memory"]
  stability: 5
  confidence: high
  api_sequence: 
    - "OpenProcess|NtOpenProcess"
    - "VirtualAllocEx|NtAllocateVirtualMemory"
    - "WriteProcessMemory|NtWriteVirtualMemory"
    - "CreateRemoteThread|CreateRemoteThreadEx|NtCreateThreadEx|RtlCreateUserThread"
    - "WaitForSingleObject|ResumeThread (if early-bird)"
  signals: 
    - "target_pid/name",
    - "start_address:<ptr> (outside loaded module?)"
    - "mem_protections:RW→RX or RWX, SEC_COMMIT"
    - "region_type:MEM_PRIVATE (vs MEM_IMAGE)"
    - "bytes_written:<len>, entropy_bucket"
  notes: "Add target process allowlist/denylist when known"

- id: archetype.injection.hollowing.v1
  name: Process hollowing (unmap -> write -> resume)
  visibility: ["memory"]
  stability: 4
  confidence: medium
  api_sequence: 
    - "CreateProcessInternalW(CREATE_SUSPENDED)"
    - "NtUnmapViewOfSection"
    - "NtAllocateVirtualMemory|VirtualAllocEx"
    - "WriteProcessMemory|NtWriteVirtualMemory"
    - "SetThreadContext|NtSetContextThread"
    - "ResumeThread"
  signals: 
    - "host_path -> payload_path (mismatch)"
    - "entrypoint_remapped"
    - "PE headers in remote memory (but not on disk)"
  notes: "Early-bird APC variant: queue APC before ResumeThread"
  
- id: archetype.injection.section_map.v1
  name: Memory-efficient, stealthy (no WriteProcessMemory)
  visibility: ["memory"]
  stability: 5
  confidence: high
  api_sequence: 
    - "NtCreateSection(SEC_COMMIT|SEC_IMAGE|sec_flags)"
    - "NtMapViewOfSection(local→RW, remote→RX)"
    - "NtCreateThreadEx|QueueUserAPC"
  signals: 
    - "section_handle_shared" 
    - "remote_view: PAGE_EXECUTE_READ, MEM_MAPPED"
  notes: "Often used with reflectively mapped PE; RW in local, RX in remote"

# MUTEX/PIPE GRAMMARS & DROPS

- id: archetype.artifact.mutex_pipe_grammars.v1
  name: Mutex & named pipe grammars
  visibility: ["memory","disk"]
  stability: 4
  confidence: high
  artifacts:
    mutex_grammar: "Global\\{GUID\\}-<tag>"     # e.g., Global\{GUID}-svc
    pipe_grammar: "\\\\.\\pipe\\<prefix>_[0-9a-f]{16}"
  notes: "Capture literal prefixes; they’re often family-specific"

- id: archetype.artifact.drop_paths_windows.v1
  name: Typical Windows drop paths
  visibility: ["disk"]
  stability: 5
  confidence: high
  artifacts:
    drop_path_templates:
      - "%APPDATA%\\<Vendor>\\<Product>\\*.dll"
      - "%LOCALAPPDATA%\\<Vendor>\\<Product>\\*.exe"
      - "%PROGRAMDATA%\\<Vendor>\\<Product>\\*.dat"
      - "C:\\Windows\\System32\\Tasks\\<Vendor>\\<Task>"
  notes: "Use templates, not literals; avoids brittleness"

# FORENSIC BREADCRUMBS

- id: archetype.forensics.windows_triad.v1
  name: Windows forensic triad (Prefetch / AmCache / Event Logs)
  schema_version: "1.0"
  visibility: ["disk","logs"]
  stability: 4
  confidence: medium
  matching: { logic: "k-of-n>=2" }   # need any 2 of the 3 to score a hit
  
  forensics:
    prefetch:
      path: "C:\\Windows\\Prefetch\\"
      patterns: ["<NAME>.EXE-*.pf"]
      signals:
        - "hash(es) of EXE from PF"
        - "run_count"
        - "last_run_ts"
        - "vol_serial"
        - "device_path_targets"       # DLL/EXE path list from PF
  
    amcache:
      hive: "C:\\Windows\\appcompat\\Programs\\Amcache.hve"
      selectors:
        - "ProgramEntries: CompanyName=<fill>, ProductName=<fill>"
        - "ProgramEntries: Path endswith \\<NAME>.exe"
      signals:
        - "sha1"
        - "first_seen_ts"
        - "last_modified_ts"
        - "size, version_info (CompanyName, ProductName, FileVersion)"
        - "volume_guid, vol_serial"
  
    event_ids:
      windows:
        # Security
        - { channel: "Security", id: 4688, hint: "Proc create: <NAME>.exe (CommandLine, ParentProcess)" }
        - { channel: "Security", id: 4697, hint: "Service install: <SvcName> (ImagePath)" }
        - { channel: "Security", id: 4698, hint: "Scheduled task created: <TaskPath><TaskName>" }
        # System
        - { channel: "System", id: 7045,  hint: "Service installed (SCM): <SvcName> (ImagePath)" }
        # Task Scheduler (Operational)
        - { channel: "Microsoft-Windows-TaskScheduler/Operational", id: 106, hint: "Task registered" }
        - { channel: "Microsoft-Windows-TaskScheduler/Operational", id: 140, hint: "Task updated" }
        # Sysmon (if present)
        - { channel: "Microsoft-Windows-Sysmon/Operational", id: 1,  hint: "Process create: <NAME>.exe (CmdLine, Hashes)" }
        - { channel: "Microsoft-Windows-Sysmon/Operational", id: 11, hint: "File create in drop path" }
        - { channel: "Microsoft-Windows-Sysmon/Operational", id: 13, hint: "Registry set (Run/IFEO)" }
        - { channel: "Microsoft-Windows-Sysmon/Operational", id: 7,  hint: "Image loaded (unbacked DLL/RWX)" }
  
  auxiliary_artifacts:         # optional but very useful pivots
    - "ShimCache (AppCompatCache): HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatCache"
    - "SRUM: C:\\Windows\\System32\\sru\\SRUDB.dat (app executions, network)"
    - "LNK/JumpLists: %APPDATA%\\Microsoft\\Windows\\Recent\\"
    - "USN Journal (change timelines), $MFT (PATH + timestamps)"
    - "WER: C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportArchive"
  
  notes: >
    Use this as a corroboration set: PF run metadata + Amcache install/use + log evidence (Security/System/Operational/Sysmon).
    Prefer channel-qualified Event IDs to avoid confusion, and require 2-of-3 sources for confidence.
  pitfalls: [
    "Prefetch: disabled on many Windows Server builds; SSDs do NOT disable PF on Win10/11.",
    "Amcache can be truncated/rolled—use first_seen_ts and SHA1 rather than only version strings.",
    "Event coverage depends on auditing/Sysmon config; check channel status before concluding absence."
  ]

# ------------------------------------------------------------------------------
# SOURCES & FURTHER READING
# This catalog mirrors how practitioners (or amateurs such as me) document durable detection knowledge.
# Key references you can consult when adding new artifacts:
#
# - MITRE ATT&CK: common language for tactics/techniques (use to label TTPs).
# - Mandiant FLARE capa (tool + rule repo): how pros encode capabilities/behaviors.
# - Sigma (spec + examples): structure for log-based detections; keeps exports clean.
# - YARA (incl. VT LiveHunt notes): rule hygiene, modifiers, and large-scale hunting.
# - TLS fingerprints: JA3/JA3S (client/server) & JARM (server) for resilient network pivots.
# - Practitioner case studies: The DFIR Report (repeatable IoCs; good for templates).
# - Family encyclopedia: Malpedia (aliases, traits) to keep naming and traits consistent.
#
# ------------------------------------------------------------------------------
